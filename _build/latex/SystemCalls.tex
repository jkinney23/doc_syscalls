%% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,english]{sphinxmanual}
\ifdefined\pdfpxdimen
   \let\sphinxpxdimen\pdfpxdimen\else\newdimen\sphinxpxdimen
\fi \sphinxpxdimen=49336sp\relax

\usepackage[margin=1in,marginparwidth=0.5in]{geometry}
\usepackage[utf8]{inputenc}
\ifdefined\DeclareUnicodeCharacter
  \DeclareUnicodeCharacter{00A0}{\nobreakspace}
\fi
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amssymb,amstext}
\usepackage{babel}
\usepackage{times}
\usepackage[Bjarne]{fncychap}
\usepackage{longtable}
\usepackage{sphinx}

\usepackage{multirow}
\usepackage{eqparbox}

% Include hyperref last.
\usepackage{hyperref}
% Fix anchor placement for figures with captions.
\usepackage{hypcap}% it must be loaded after hyperref.
% Set up styles of URL: it should be placed after hyperref.
\urlstyle{same}
\addto\captionsenglish{\renewcommand{\contentsname}{Contents:}}

\addto\captionsenglish{\renewcommand{\figurename}{Fig.\@ }}
\addto\captionsenglish{\renewcommand{\tablename}{Table }}
\addto\captionsenglish{\renewcommand{\literalblockname}{Listing }}

\addto\extrasenglish{\def\pageautorefname{page}}

\setcounter{tocdepth}{1}



\title{System Calls and Glibc}
\date{May 02, 2017}
\release{1.0}
\author{Rishi Agrawal <rishi.b.agrawal@gmail.com>}
\newcommand{\sphinxlogo}{}
\renewcommand{\releasename}{Release}
\makeindex

\begin{document}

\maketitle
\sphinxtableofcontents
\phantomsection\label{\detokenize{index::doc}}



\chapter{Introduction}
\label{\detokenize{01_introduction:system-call-layer}}\label{\detokenize{01_introduction:introduction}}\label{\detokenize{01_introduction::doc}}
In this white paper we will see how your code interacts with the glibc library and
then the system calls in order to get some work done from the computer.

We will go deep into the code and see how it is all organized. How system calls
are called from the user space programs.  How arguements are passed and how is
return value accessed.

We will see the code, we will see the same thing using debugger and then we
will write our own small \sphinxcode{strace} to see what the \sphinxcode{strace}  actually does when
it lists the paramters to you.


\section{Acknowledgements}
\label{\detokenize{01_introduction:acknowledgements}}
Most of the contents in the paper is inspired from the contents in the internet
and various blogs.

I wanted to understand the whole process of the glibc and system calls and
while doing that - I just documented the whole thing.

Wherever possilble I have given links of the reference point.


\chapter{System Architecture}
\label{\detokenize{02_system_calls:system-architecture}}\label{\detokenize{02_system_calls::doc}}
\begin{sphinxadmonition}{note}{Todo}

Write about System archtecture - little bit about how a process links with the libraries etc.
\end{sphinxadmonition}


\section{Shared Library}
\label{\detokenize{02_system_calls:shared-library}}
\begin{sphinxadmonition}{note}{Todo}

Write about Shared library.
\end{sphinxadmonition}


\section{Static Library}
\label{\detokenize{02_system_calls:static-library}}
\begin{sphinxadmonition}{note}{Todo}

Write about Static Library.
\end{sphinxadmonition}


\section{System Calls}
\label{\detokenize{02_system_calls:system-calls}}
System calls are API's which the Kernel Provides to the user space
applications. The system calls pass some arguements to the kernel space and the
kernel acts accordingly on the arguements.

For example: \sphinxcode{open()} system call - opens a file so that further read and
write operations can be done on the file. The return value of the \sphinxcode{open}
system call is a \sphinxcode{file descriptor} or an \sphinxcode{error status}. Sucessful return value
allows the user space applications to use the \sphinxcode{file descriptor} for further reads
and writes.

System calls get executed in the kernel space. Kernel space runs in an elevated
prviledge mode. There is a shift of the priviledge modes whenever a system call
is called and hence its a bad idea to call system calls without considering the
time taken to switch to the elevated priviledge mode.

For example - lets say that you want to copy a file. One way of copying the file
is to read each character of the file and for every character read you write the
character to another file. This will call two system calls for every
character you read and write. As this is expensive in terms of time its a bad
design.

Let us see a small demostration of this.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+cm}{/*}
\PYG{c+cm}{ * In this code we will open the /etc/passwd file and copy the file 1000 times}
\PYG{c+cm}{ * to the output file. We will copy it 1000 times so that we have a good amount}
\PYG{c+cm}{ * data to run our test on.}
\PYG{c+cm}{ */}

\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}stdlib.h\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}fcntl.h\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}stdio.h\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}unistd.h\PYGZgt{}}

\PYG{k+kt}{int} \PYG{n+nf}{main} \PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{k+kt}{char} \PYG{o}{*}\PYG{n}{src\PYGZus{}file} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{src\PYGZus{}file}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
    \PYG{k+kt}{char} \PYG{o}{*}\PYG{n}{dest\PYGZus{}file} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{copied\PYGZus{}file.txt}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}

    \PYG{k+kt}{int} \PYG{n}{dest\PYGZus{}fd}\PYG{p}{,} \PYG{n}{src\PYGZus{}fd}\PYG{p}{,} \PYG{n}{read\PYGZus{}byte}\PYG{p}{,} \PYG{n}{write\PYGZus{}byte}\PYG{p}{;}
    \PYG{k+kt}{char} \PYG{n}{read\PYGZus{}buf}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{;}

    \PYG{n}{dest\PYGZus{}fd} \PYG{o}{=} \PYG{n}{open} \PYG{p}{(}\PYG{n}{dest\PYGZus{}file}\PYG{p}{,} \PYG{n}{O\PYGZus{}WRONLY}\PYG{o}{\textbar{}}\PYG{n}{O\PYGZus{}CREAT}\PYG{p}{)}\PYG{p}{;}

    \PYG{k}{if} \PYG{p}{(}\PYG{n}{dest\PYGZus{}fd} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{0}\PYG{p}{)} \PYG{p}{\PYGZob{}}
        \PYG{n}{fprintf} \PYG{p}{(}\PYG{n}{stderr}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Error Opening the destination file.}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{exit}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}} \PYG{k}{else} \PYG{p}{\PYGZob{}}
        \PYG{n}{fprintf} \PYG{p}{(}\PYG{n}{stderr}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Successfully opened the destination file..}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{n}{src\PYGZus{}fd} \PYG{o}{=} \PYG{n}{open} \PYG{p}{(}\PYG{n}{src\PYGZus{}file}\PYG{p}{,} \PYG{n}{O\PYGZus{}RDONLY}\PYG{p}{)}\PYG{p}{;}

    \PYG{k}{if} \PYG{p}{(}\PYG{n}{src\PYGZus{}fd} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{0}\PYG{p}{)} \PYG{p}{\PYGZob{}}
        \PYG{n}{fprintf} \PYG{p}{(}\PYG{n}{stderr}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Error Opening the source file.}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{exit}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}} \PYG{k}{else} \PYG{p}{\PYGZob{}}
        \PYG{n}{fprintf} \PYG{p}{(}\PYG{n}{stderr}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Successfully opened the source file.}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}


    \PYG{c+cm}{/*}
\PYG{c+cm}{     * We will start the copy process byte by byte}
\PYG{c+cm}{     */}

    \PYG{k}{while} \PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)} \PYG{p}{\PYGZob{}}
        \PYG{n}{read\PYGZus{}byte} \PYG{o}{=} \PYG{n}{read} \PYG{p}{(}\PYG{n}{src\PYGZus{}fd}\PYG{p}{,} \PYG{n}{read\PYGZus{}buf}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{if} \PYG{p}{(}\PYG{n}{read\PYGZus{}byte} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)} \PYG{p}{\PYGZob{}}
            \PYG{n}{fprintf}\PYG{p}{(}\PYG{n}{stdout}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Reached the EOF for src file}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
            \PYG{k}{break}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{n}{write\PYGZus{}byte} \PYG{o}{=} \PYG{n}{write} \PYG{p}{(}\PYG{n}{dest\PYGZus{}fd}\PYG{p}{,} \PYG{n}{read\PYGZus{}buf}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}

        \PYG{k}{if} \PYG{p}{(}\PYG{n}{write\PYGZus{}byte} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{0}\PYG{p}{)} \PYG{p}{\PYGZob{}}
            \PYG{n}{perror} \PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Error Writing File}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
            \PYG{n}{exit} \PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
    \PYG{p}{\PYGZcb{}}

    \PYG{n}{close}\PYG{p}{(}\PYG{n}{src\PYGZus{}fd}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{close}\PYG{p}{(}\PYG{n}{dest\PYGZus{}fd}\PYG{p}{)}\PYG{p}{;}

    \PYG{k}{return} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

What should instead be done here is that you read a block (set of characters)
and then write that block into another file. This will reduce the number of the
system calls and thus increase the overall performance of the file copy
program.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+cm}{/*}
\PYG{c+cm}{ * In this code we will open the /etc/passwd file and copy the file 1000 times}
\PYG{c+cm}{ * to the output file. We will copy it 1000 times so that we have a good amount}
\PYG{c+cm}{ * data to run our test on.}
\PYG{c+cm}{ */}

\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}stdlib.h\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}fcntl.h\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}stdio.h\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}unistd.h\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}errno.h\PYGZgt{}}

\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define BLOCK\PYGZus{}SIZE 4096}

\PYG{k+kt}{int} \PYG{n+nf}{main} \PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{k+kt}{char} \PYG{o}{*}\PYG{n}{src\PYGZus{}file} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{src\PYGZus{}file}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
    \PYG{k+kt}{char} \PYG{o}{*}\PYG{n}{dest\PYGZus{}file} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{copied\PYGZus{}file.txt}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}

    \PYG{k+kt}{int} \PYG{n}{dest\PYGZus{}fd}\PYG{p}{,} \PYG{n}{src\PYGZus{}fd}\PYG{p}{,} \PYG{n}{read\PYGZus{}byte}\PYG{p}{,} \PYG{n}{write\PYGZus{}byte}\PYG{p}{;}
    \PYG{k+kt}{char} \PYG{n}{read\PYGZus{}buf}\PYG{p}{[}\PYG{n}{BLOCK\PYGZus{}SIZE}\PYG{p}{]}\PYG{p}{;}

    \PYG{n}{dest\PYGZus{}fd} \PYG{o}{=} \PYG{n}{open} \PYG{p}{(}\PYG{n}{dest\PYGZus{}file}\PYG{p}{,} \PYG{n}{O\PYGZus{}WRONLY}\PYG{o}{\textbar{}}\PYG{n}{O\PYGZus{}CREAT}\PYG{p}{,} \PYG{n}{S\PYGZus{}IRWXU}\PYG{o}{\textbar{}}\PYG{n}{S\PYGZus{}IRWXG}\PYG{o}{\textbar{}}\PYG{n}{S\PYGZus{}IROTH}\PYG{p}{)}\PYG{p}{;}

    \PYG{k}{if} \PYG{p}{(}\PYG{n}{dest\PYGZus{}fd} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{0}\PYG{p}{)} \PYG{p}{\PYGZob{}}
        \PYG{n}{perror} \PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{Error opening the destination file}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{exit}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}} \PYG{k}{else} \PYG{p}{\PYGZob{}}
        \PYG{n}{fprintf} \PYG{p}{(}\PYG{n}{stderr}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{Successfully opened the destination file..}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{n}{src\PYGZus{}fd} \PYG{o}{=} \PYG{n}{open} \PYG{p}{(}\PYG{n}{src\PYGZus{}file}\PYG{p}{,} \PYG{n}{O\PYGZus{}RDONLY}\PYG{p}{)}\PYG{p}{;}

    \PYG{k}{if} \PYG{p}{(}\PYG{n}{src\PYGZus{}fd} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{0}\PYG{p}{)} \PYG{p}{\PYGZob{}}
        \PYG{n}{perror} \PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{Error opening the source file}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{exit}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}} \PYG{k}{else} \PYG{p}{\PYGZob{}}
        \PYG{n}{fprintf} \PYG{p}{(}\PYG{n}{stderr}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Successfully opened the source file.}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}


    \PYG{c+cm}{/*}
\PYG{c+cm}{     * We will start the copy process byte by byte}
\PYG{c+cm}{     */}

    \PYG{k}{while} \PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)} \PYG{p}{\PYGZob{}}
        \PYG{n}{read\PYGZus{}byte} \PYG{o}{=} \PYG{n}{read} \PYG{p}{(}\PYG{n}{src\PYGZus{}fd}\PYG{p}{,} \PYG{n}{read\PYGZus{}buf}\PYG{p}{,} \PYG{n}{BLOCK\PYGZus{}SIZE}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{if} \PYG{p}{(}\PYG{n}{read\PYGZus{}byte} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)} \PYG{p}{\PYGZob{}}
            \PYG{n}{fprintf}\PYG{p}{(}\PYG{n}{stdout}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Reached the EOF for src file}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
            \PYG{k}{break}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{n}{write\PYGZus{}byte} \PYG{o}{=} \PYG{n}{write} \PYG{p}{(}\PYG{n}{dest\PYGZus{}fd}\PYG{p}{,} \PYG{n}{read\PYGZus{}buf}\PYG{p}{,} \PYG{n}{BLOCK\PYGZus{}SIZE}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{if} \PYG{p}{(}\PYG{n}{write\PYGZus{}byte} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{0}\PYG{p}{)} \PYG{p}{\PYGZob{}}
            \PYG{n}{perror} \PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Erroo writing file}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
            \PYG{n}{exit}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
    \PYG{p}{\PYGZcb{}}

    \PYG{n}{close}\PYG{p}{(}\PYG{n}{src\PYGZus{}fd}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{close}\PYG{p}{(}\PYG{n}{dest\PYGZus{}fd}\PYG{p}{)}\PYG{p}{;}

    \PYG{k}{return} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n+nf}{all}\PYG{o}{:}
	gcc \PYGZhy{}o slow\PYGZus{}write slow\PYGZus{}write.c \PYGZhy{}Wall
	gcc \PYGZhy{}o fast\PYGZus{}write fast\PYGZus{}write.c \PYGZhy{}Wall

\PYG{n+nf}{run}\PYG{o}{:}
	\PYG{n+nb}{time} slow\PYGZus{}write
	\PYG{n+nb}{time} fast\PYGZus{}write

\PYG{n+nf}{clean}\PYG{o}{:}
	rm src\PYGZus{}file slow\PYGZus{}write fast\PYGZus{}write copied\PYGZus{}file.txt

\PYG{n+nf}{setup}\PYG{o}{:}
	\PYG{k}{for} i in \PYG{l+s+sb}{{}`}seq \PYG{l+m}{1} 1000\PYG{l+s+sb}{{}`}\PYG{p}{;} \PYG{k}{do} cat /etc/passwd \PYGZgt{}\PYGZgt{} src\PYGZus{}file\PYG{p}{;} \PYG{k}{done} 
\end{sphinxVerbatim}


\section{References}
\label{\detokenize{02_system_calls:references}}

\chapter{Working with \sphinxstyleliteralintitle{glibc}}
\label{\detokenize{03_glibc:working-with-glibc}}\label{\detokenize{03_glibc::doc}}

\section{Introduction}
\label{\detokenize{03_glibc:introduction}}

\section{Why this chapter}
\label{\detokenize{03_glibc:why-this-chapter}}

\section{What is \sphinxstyleliteralintitle{glibc}}
\label{\detokenize{03_glibc:what-is-glibc}}
\sphinxcode{glibc} is a library which has a lot of functions pre-written for you so that
you do not have to write the code again and again. Also it statndardizes the
way you should be writing your code. It warps a lot of system specific details
and all you need to know is to how to call the particular function, and what to
be expected from the function and what are the return values the function will
give you.

It is the \sphinxcode{GNU Version of Standard C Library}. All the functions
supported in \sphinxcode{Standard C Library} can be found there + some added by the
\sphinxcode{GNU}

\begin{sphinxadmonition}{note}{Todo}

Give an example of a function in Standard C and Not in GNU LibC
\end{sphinxadmonition}

\begin{sphinxadmonition}{note}{Todo}

Give an example of a function in GLIBC and not in Standard C.
\end{sphinxadmonition}

\sphinxstylestrong{For example:} Let us say that we have to find the length of a string. Now this
is quite a small code to write and we can write the whole thing ourself, but it
is a function which is used a lot of times. So the library gives you an
implementation of this. As that function is present in the library you can
safely assume that the function will work fine because of millions of people
have used it and tested it.

You can add your own code to the library and modify the functions to suit your need.

For the sake of understanding it better we will now go into the code of the
library function and see if its similar to our code.

Also we will make some changes to the code so that it stops working incorrectly
and then use it in our programs. This exercise is just a demostration of the
following.
\begin{itemize}
\item {} 
We can read the code of glibc

\item {} 
We can compile the code of glibc ourselves and use the newly compiled library

\item {} 
We can change the code of glibc

\item {} 
We can use the changed code of glibc

\end{itemize}


\section{Download, Extract and walk through \sphinxstyleliteralintitle{glibc}}
\label{\detokenize{03_glibc:download-extract-and-walk-through-glibc}}

\section{Download and extract \sphinxstyleliteralintitle{glibc}}
\label{\detokenize{03_glibc:download-and-extract-glibc}}
The source code of glibc is available at \sphinxcode{https://ftp.gnu.org/gnu/libc/}. You
can sort the list using \sphinxcode{Last Modified} to get the latest tar package.

From the page I got the link as \sphinxcode{https://ftp.gnu.org/gnu/libc/glibc-2.24.tar.xz}.
\begin{itemize}
\item {} 
Let us download this source, see the following snippet for the exact commands.

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} wget https://ftp.gnu.org/gnu/libc/glibc\PYGZhy{}2.24.tar.xz
\PYGZhy{}\PYGZhy{}2017\PYGZhy{}01\PYGZhy{}29 07:50:02\PYGZhy{}\PYGZhy{}  https://ftp.gnu.org/gnu/libc/glibc\PYGZhy{}2.24.tar.xz
Resolving ftp.gnu.org (ftp.gnu.org)... 208.118.235.20, 2001:4830:134:3::b
Connecting to ftp.gnu.org (ftp.gnu.org)\textbar{}208.118.235.20\textbar{}:443... connected.
HTTP request sent, awaiting response... 200 OK
Length: 13554048 (13M) [application/x\PYGZhy{}tar]
Saving to: ‘glibc\PYGZhy{}2.24.tar.xz’

glibc\PYGZhy{}2.24.tar.xz                     100\PYGZpc{}[==\PYGZgt{}]  12.93M   709KB/s    in 21s

2017\PYGZhy{}01\PYGZhy{}29 07:50:26 (622 KB/s) \PYGZhy{} ‘glibc\PYGZhy{}2.24.tar.xz’ saved [13554048/13554048]
\end{sphinxVerbatim}


\subsection{Extract the code}
\label{\detokenize{03_glibc:extract-the-code}}\begin{itemize}
\item {} 
The downloaded code is a compressed tar file. We need to extract it.

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
rishi@rishi\PYGZhy{}VirtualBox:\PYGZti{}\PYGZdl{} tar \PYGZhy{}xf glibc\PYGZhy{}2.24.tar.xz
\end{sphinxVerbatim}
\begin{itemize}
\item {} 
This creates a directory names \sphinxcode{glibc-2.24} in the folder.

\end{itemize}


\section{Walkthrough \sphinxstyleliteralintitle{glibc}}
\label{\detokenize{03_glibc:walkthrough-glibc}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
rishi@rishi\PYGZhy{}VirtualBox:\PYGZti{}\PYGZdl{} cd glibc\PYGZhy{}2.24/
rishi@rishi\PYGZhy{}VirtualBox:\PYGZti{}/glibc\PYGZhy{}2.24\PYGZdl{} ls
abi\PYGZhy{}tags          ChangeLog.3                        ChangeLog.old\PYGZhy{}ports\PYGZhy{}mips
aclocal.m4        ChangeLog.4                        ChangeLog.old\PYGZhy{}ports\PYGZhy{}powerpc
argp              ChangeLog.5                        ChangeLog.old\PYGZhy{}ports\PYGZhy{}tile
assert            ChangeLog.6                        config.h.in
benchtests        ChangeLog.7                        config.make.in
bits              ChangeLog.8                        configure
BUGS              ChangeLog.9                        configure.ac
catgets           ChangeLog.old\PYGZhy{}ports                conform
ChangeLog         ChangeLog.old\PYGZhy{}ports\PYGZhy{}aarch64        CONFORMANCE
ChangeLog.1       ChangeLog.old\PYGZhy{}ports\PYGZhy{}aix            COPYING
ChangeLog.10      ChangeLog.old\PYGZhy{}ports\PYGZhy{}alpha          COPYING.LIB
ChangeLog.11      ChangeLog.old\PYGZhy{}ports\PYGZhy{}am33           cppflags\PYGZhy{}iterator.mk
ChangeLog.12      ChangeLog.old\PYGZhy{}ports\PYGZhy{}arm            crypt
ChangeLog.13      ChangeLog.old\PYGZhy{}ports\PYGZhy{}cris           csu
ChangeLog.14      ChangeLog.old\PYGZhy{}ports\PYGZhy{}hppa           ctype
ChangeLog.15      ChangeLog.old\PYGZhy{}ports\PYGZhy{}ia64           debug
ChangeLog.16      ChangeLog.old\PYGZhy{}ports\PYGZhy{}linux\PYGZhy{}generic  dirent
ChangeLog.17      ChangeLog.old\PYGZhy{}ports\PYGZhy{}m68k           dlfcn
ChangeLog.2       ChangeLog.old\PYGZhy{}ports\PYGZhy{}microblaze     elf
extra\PYGZhy{}lib.mk      LICENSES     nscd                  stdio\PYGZhy{}common
extra\PYGZhy{}modules.mk  locale       nss                   stdlib
gen\PYGZhy{}locales.mk    localedata   o\PYGZhy{}iterator.mk         streams
gmon              login        po                    string
gnulib            mach         posix                 sunrpc
grp               Makeconfig   PROJECTS              sysdeps
gshadow           Makefile     pwd                   sysvipc
hesiod            Makefile.in  README                termios
hurd              Makerules    resolv          test\PYGZhy{}skeleton
iconv             malloc       resource        time
iconvdata         manual       rt              timezone
include           math         Rules           version.h
inet              mathvec      scripts         wcsmbs
INSTALL           misc         setjmp          wctype
intl              NAMESPACE    shadow          WUR\PYGZhy{}REPORT
io                NEWS         shlib\PYGZhy{}versions
libc\PYGZhy{}abis         nis          signal
libidn            nptl         socket
libio             nptl\PYGZus{}db      soft\PYGZhy{}fp
\end{sphinxVerbatim}

Some string related code is here

\begin{sphinxVerbatim}[commandchars=\\\{\}]
rishi@rishi\PYGZhy{}VirtualBox:\PYGZti{}/glibc\PYGZhy{}2.24\PYGZdl{} ls string/str*
string/stratcliff.c    string/strcmp.c     string/strerror\PYGZus{}l.c      string/strncase\PYGZus{}l.c  string/strrchr.c    string/str\PYGZhy{}two\PYGZhy{}way.h
string/strcasecmp.c    string/strcoll.c    string/strfry.c          string/strncat.c     string/strsep.c     string/strverscmp.c
string/strcasecmp\PYGZus{}l.c  string/strcoll\PYGZus{}l.c  string/string.h          string/strncmp.c     string/strsignal.c  string/strxfrm.c
string/strcasestr.c    string/strcpy.c     string/string\PYGZhy{}inlines.c  string/strncpy.c     string/strspn.c     string/strxfrm\PYGZus{}l.c
string/strcat.c        string/strcspn.c    string/strings.h         string/strndup.c     string/strstr.c
string/strchr.c        string/strdup.c     string/strlen.c          string/strnlen.c     string/strtok.c
string/strchrnul.c     string/strerror.c   string/strncase.c        string/strpbrk.c     string/strtok\PYGZus{}r.c
\end{sphinxVerbatim}

Some math related code is here

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} ls math/w\PYGZus{}*
math/w\PYGZus{}acos.c    math/w\PYGZus{}atanhf.c  math/w\PYGZus{}fmodf.c   math/w\PYGZus{}j1l.c             math/w\PYGZus{}lgammal\PYGZus{}r.c    math/w\PYGZus{}logf.c        math/w\PYGZus{}scalblnl.c
math/w\PYGZus{}acosf.c   math/w\PYGZus{}atanhl.c  math/w\PYGZus{}fmodl.c   math/w\PYGZus{}jn.c              math/w\PYGZus{}lgamma\PYGZus{}main.c  math/w\PYGZus{}logl.c        math/w\PYGZus{}sinh.c
math/w\PYGZus{}acosh.c   math/w\PYGZus{}cosh.c    math/w\PYGZus{}hypot.c   math/w\PYGZus{}jnf.c             math/w\PYGZus{}lgamma\PYGZus{}r.c     math/w\PYGZus{}pow.c         math/w\PYGZus{}sinhf.c
math/w\PYGZus{}acoshf.c  math/w\PYGZus{}coshf.c   math/w\PYGZus{}hypotf.c  math/w\PYGZus{}jnl.c             math/w\PYGZus{}log10.c        math/w\PYGZus{}powf.c        math/w\PYGZus{}sinhl.c
math/w\PYGZus{}acoshl.c  math/w\PYGZus{}coshl.c   math/w\PYGZus{}hypotl.c  math/w\PYGZus{}lgamma.c          math/w\PYGZus{}log10f.c       math/w\PYGZus{}powl.c        math/w\PYGZus{}sqrt.c
math/w\PYGZus{}acosl.c   math/w\PYGZus{}exp10.c   math/w\PYGZus{}ilogb.c   math/w\PYGZus{}lgamma\PYGZus{}compat.c   math/w\PYGZus{}log10l.c       math/w\PYGZus{}remainder.c   math/w\PYGZus{}sqrtf.c
math/w\PYGZus{}asin.c    math/w\PYGZus{}exp10f.c  math/w\PYGZus{}ilogbf.c  math/w\PYGZus{}lgamma\PYGZus{}compatf.c  math/w\PYGZus{}log1p.c        math/w\PYGZus{}remainderf.c  math/w\PYGZus{}sqrtl.c
math/w\PYGZus{}asinf.c   math/w\PYGZus{}exp10l.c  math/w\PYGZus{}ilogbl.c  math/w\PYGZus{}lgamma\PYGZus{}compatl.c  math/w\PYGZus{}log1pf.c       math/w\PYGZus{}remainderl.c  math/w\PYGZus{}tgamma.c
math/w\PYGZus{}asinl.c   math/w\PYGZus{}exp2.c    math/w\PYGZus{}j0.c      math/w\PYGZus{}lgammaf.c         math/w\PYGZus{}log1pl.c       math/w\PYGZus{}scalb.c       math/w\PYGZus{}tgammaf.c
math/w\PYGZus{}atan2.c   math/w\PYGZus{}exp2f.c   math/w\PYGZus{}j0f.c     math/w\PYGZus{}lgammaf\PYGZus{}main.c    math/w\PYGZus{}log2.c         math/w\PYGZus{}scalbf.c      math/w\PYGZus{}tgammal.c
math/w\PYGZus{}atan2f.c  math/w\PYGZus{}exp2l.c   math/w\PYGZus{}j0l.c     math/w\PYGZus{}lgammaf\PYGZus{}r.c       math/w\PYGZus{}log2f.c        math/w\PYGZus{}scalbl.c
math/w\PYGZus{}atan2l.c  math/w\PYGZus{}expl.c    math/w\PYGZus{}j1.c      math/w\PYGZus{}lgammal.c         math/w\PYGZus{}log2l.c        math/w\PYGZus{}scalbln.c
math/w\PYGZus{}atanh.c   math/w\PYGZus{}fmod.c    math/w\PYGZus{}j1f.c     math/w\PYGZus{}lgammal\PYGZus{}main.c    math/w\PYGZus{}log.c          math/w\PYGZus{}scalblnf.c
\end{sphinxVerbatim}

The header files for the library is here.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} ls include/
aio.h       ctype.h     fenv.h          grp\PYGZhy{}merge.h        link.h      netinet     resolv.h          spawn.h           syscall.h   utmp.h
aliases.h   des.h       fmtmsg.h        gshadow.h          list.h      nl\PYGZus{}types.h  rounding\PYGZhy{}mode.h   stab.h            sysexits.h  values.h
alloca.h    dirent.h    fnmatch.h       iconv.h            locale.h    nss.h       rpc               stackinfo.h       syslog.h    wchar.h
argp.h      dlfcn.h     fpu\PYGZus{}control.h   ifaddrs.h          malloc.h    nsswitch.h  rpcsvc            stap\PYGZhy{}probe.h      tar.h       wctype.h
argz.h      elf.h       ftw.h           ifunc\PYGZhy{}impl\PYGZhy{}list.h  math.h      obstack.h   sched.h           stdc\PYGZhy{}predef.h     termios.h   wordexp.h
arpa        endian.h    gconv.h         inline\PYGZhy{}hashtab.h   mcheck.h    poll.h      scratch\PYGZus{}buffer.h  stdio\PYGZus{}ext.h       tgmath.h    xlocale.h
assert.h    envz.h      getopt.h        langinfo.h         memory.h    printf.h    search.h          stdio.h           time.h
atomic.h    err.h       getopt\PYGZus{}int.h    libc\PYGZhy{}internal.h    mntent.h    programs    set\PYGZhy{}hooks.h       stdlib.h          ttyent.h
bits        errno.h     glob.h          libc\PYGZhy{}symbols.h     monetary.h  protocols   setjmp.h          string.h          uchar.h
byteswap.h  error.h     gmp.h           libgen.h           mqueue.h    pthread.h   sgtty.h           strings.h         ucontext.h
caller.h    execinfo.h  gnu             libintl.h          net         pty.h       shadow.h          stropts.h         ulimit.h
complex.h   fcntl.h     gnu\PYGZhy{}versions.h  libio.h            netdb.h     pwd.h       shlib\PYGZhy{}compat.h    stubs\PYGZhy{}prologue.h  unistd.h
cpio.h      features.h  grp.h           limits.h           netgroup.h  regex.h     signal.h          sys               utime.h
\end{sphinxVerbatim}


\subsection{Walkthrough \sphinxstyleliteralintitle{strlen}}
\label{\detokenize{03_glibc:walkthrough-strlen}}
\begin{sphinxadmonition}{note}{Todo}

write this section.
\end{sphinxadmonition}


\subsection{Walkthrough \sphinxstyleliteralintitle{div}}
\label{\detokenize{03_glibc:walkthrough-div}}
\begin{sphinxadmonition}{note}{Todo}

write this section.
\end{sphinxadmonition}


\subsection{Walkthrough \sphinxstyleliteralintitle{open}}
\label{\detokenize{03_glibc:walkthrough-open}}
\begin{sphinxadmonition}{note}{Todo}

write this section.
\end{sphinxadmonition}


\section{Compiling the code of glibc}
\label{\detokenize{03_glibc:compiling-the-code-of-glibc}}
Generally compling and installing code on Linux system involves the following stages
\begin{enumerate}
\item {} 
Configuring -   running \sphinxcode{configure} with right options.

\item {} 
Compiling   -   running \sphinxcode{make} with right options.

\item {} 
Install     -   running \sphinxcode{make install}.

\end{enumerate}


\subsection{Configuring}
\label{\detokenize{03_glibc:configuring}}
We will get into the glibc-2.24 source directory and run the \sphinxcode{configure} script. I have intentionally shown the mistakes which happened so that you also understand the small things which needs to be taken care while configuring and compling.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
rishi@rishi\PYGZhy{}VirtualBox:\PYGZti{}/glibc\PYGZhy{}2.24\PYGZdl{} ./configure
checking build system type... x86\PYGZus{}64\PYGZhy{}pc\PYGZhy{}linux\PYGZhy{}gnu
checking host system type... x86\PYGZus{}64\PYGZhy{}pc\PYGZhy{}linux\PYGZhy{}gnu
checking for gcc... gcc
checking for suffix of object files... o
checking whether we are using the GNU C compiler... yes
checking whether gcc accepts \PYGZhy{}g... yes
checking for readelf... readelf
checking for g++... g++
checking whether we are using the GNU C++ compiler... yes
checking whether g++ accepts \PYGZhy{}g... yes
checking whether g++ can link programs... yes
configure: error: you must configure in a separate build directory
\end{sphinxVerbatim}
\begin{itemize}
\item {} 
We got an error that we should use a separate directory for running \sphinxcode{configure}

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
rishi@rishi\PYGZhy{}VirtualBox:\PYGZti{}/glibc\PYGZhy{}2.24\PYGZdl{} mkdir ../build\PYGZus{}glibc

rishi@rishi\PYGZhy{}VirtualBox:\PYGZti{}/glibc\PYGZhy{}2.24\PYGZdl{} cd ../build\PYGZus{}glibc/
\end{sphinxVerbatim}
\begin{itemize}
\item {} 
Let us now run the configure command.

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
rishi@rishi\PYGZhy{}VirtualBox:\PYGZti{}/build\PYGZus{}glibc\PYGZdl{} ../glibc\PYGZhy{}2.24/configure
checking build system type... x86\PYGZus{}64\PYGZhy{}pc\PYGZhy{}linux\PYGZhy{}gnu
checking host system type... x86\PYGZus{}64\PYGZhy{}pc\PYGZhy{}linux\PYGZhy{}gnu
checking for gcc... gcc
checking for suffix of object files... o
checking version of sed... 4.2.2, ok
checking for gawk... no

\PYGZgt{}\PYGZgt{}\PYGZgt{}\PYGZgt{}\PYGZgt{}\PYGZgt{}\PYGZgt{}\PYGZgt{}\PYGZgt{}\PYGZgt{}\PYGZgt{}\PYGZgt{}\PYGZgt{}\PYGZgt{}\PYGZgt{}\PYGZgt{}\PYGZgt{}SNIP\PYGZlt{}\PYGZlt{}\PYGZlt{}\PYGZlt{}\PYGZlt{}\PYGZlt{}\PYGZlt{}\PYGZlt{}\PYGZlt{}\PYGZlt{}\PYGZlt{}\PYGZlt{}\PYGZlt{}\PYGZlt{}\PYGZlt{}\PYGZlt{}\PYGZlt{}\PYGZlt{}\PYGZlt{}\PYGZlt{}\PYGZlt{}\PYGZlt{}

checking if gcc is sufficient to build libc... yes
checking for nm... nm
configure: error:
*** These critical programs are missing or too old: gawk
*** Check the INSTALL file for required versions.
\end{sphinxVerbatim}
\begin{itemize}
\item {} 
The configure step gave errors - let us install \sphinxcode{gawk} now.

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
rishi@rishi\PYGZhy{}VirtualBox:\PYGZti{}/build\PYGZus{}glibc\PYGZdl{} sudo apt\PYGZhy{}get install gawk
[sudo] password for rishi:
Reading package lists... Done
Building dependency tree
Reading state information... Done
The following additional packages will be installed:
libsigsegv2
Suggested packages:
gawk\PYGZhy{}doc
The following NEW packages will be installed:
gawk libsigsegv2

\PYGZgt{}\PYGZgt{}\PYGZgt{}\PYGZgt{}\PYGZgt{}\PYGZgt{}\PYGZgt{}\PYGZgt{}\PYGZgt{}\PYGZgt{}\PYGZgt{}\PYGZgt{}\PYGZgt{}SNIP\PYGZlt{}\PYGZlt{}\PYGZlt{}\PYGZlt{}\PYGZlt{}\PYGZlt{}\PYGZlt{}\PYGZlt{}\PYGZlt{}\PYGZlt{}\PYGZlt{}\PYGZlt{}\PYGZlt{}\PYGZlt{}

Setting up gawk (1:4.1.3+dfsg\PYGZhy{}0.1) ...
\end{sphinxVerbatim}
\begin{itemize}
\item {} 
Check if the command is present.

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
rishi@rishi\PYGZhy{}office:\PYGZti{}/mydev/publications/system\PYGZus{}calls\PYGZdl{} which gawk
/usr/bin/gawk
\end{sphinxVerbatim}
\begin{itemize}
\item {} 
Let us run configure again

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
rishi@rishi\PYGZhy{}VirtualBox:\PYGZti{}/build\PYGZus{}glibc\PYGZdl{} ../glibc\PYGZhy{}2.24/configure
checking build system type... x86\PYGZus{}64\PYGZhy{}pc\PYGZhy{}linux\PYGZhy{}gnu
checking host system type... x86\PYGZus{}64\PYGZhy{}pc\PYGZhy{}linux\PYGZhy{}gnu
checking for gcc... gcc
checking for suffix of object files... o
checking whether we are using the GNU C compiler... yes

\PYGZgt{}\PYGZgt{}\PYGZgt{}\PYGZgt{}\PYGZgt{}\PYGZgt{}\PYGZgt{}\PYGZgt{}\PYGZgt{}\PYGZgt{}SNIP\PYGZlt{}\PYGZlt{}\PYGZlt{}\PYGZlt{}\PYGZlt{}\PYGZlt{}\PYGZlt{}\PYGZlt{}\PYGZlt{}\PYGZlt{}\PYGZlt{}\PYGZlt{}\PYGZlt{}\PYGZlt{}\PYGZlt{}\PYGZlt{}\PYGZlt{}\PYGZlt{}\PYGZlt{}\PYGZlt{}\PYGZlt{}\PYGZlt{}

running configure fragment for sysdeps/unix/sysv/linux/x86\PYGZus{}64
running configure fragment for sysdeps/unix/sysv/linux
checking installed Linux kernel header files... 3.2.0 or later
checking for kernel header at least 2.6.32... ok
*** On GNU/Linux systems the GNU C Library should not be installed into
*** /usr/local since this might make your system totally unusable.
*** We strongly advise to use a different prefix.  For details read the FAQ.
*** If you really mean to do this, run configure again using the extra
*** parameter {}`\PYGZhy{}\PYGZhy{}disable\PYGZhy{}sanity\PYGZhy{}checks{}`.
\end{sphinxVerbatim}
\begin{itemize}
\item {} 
Configure does not want to overwrite the default library and hence we need to give another directory to install the library.

\item {} 
Let us make a directory and run the configure script.

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
rishi@rishi\PYGZhy{}VirtualBox:\PYGZti{}/build\PYGZus{}glibc\PYGZdl{} mkdir ../install\PYGZus{}glibc
rishi@rishi\PYGZhy{}VirtualBox:\PYGZti{}/build\PYGZus{}glibc\PYGZdl{} ../glibc\PYGZhy{}2.24/configure \PYGZhy{}\PYGZhy{}prefix=/home/rishi/install\PYGZus{}glibc/
checking build system type... x86\PYGZus{}64\PYGZhy{}pc\PYGZhy{}linux\PYGZhy{}gnu
checking host system type... x86\PYGZus{}64\PYGZhy{}pc\PYGZhy{}linux\PYGZhy{}gnu
checking for gcc... gcc
checking for suffix of object files... o
configure: creating ./config.status

\PYGZgt{}\PYGZgt{}\PYGZgt{}\PYGZgt{}\PYGZgt{}\PYGZgt{}\PYGZgt{}SNIP\PYGZlt{}\PYGZlt{}\PYGZlt{}\PYGZlt{}\PYGZlt{}\PYGZlt{}\PYGZlt{}\PYGZlt{}\PYGZlt{}\PYGZlt{}\PYGZlt{}\PYGZlt{}

config.status: creating config.make
config.status: creating Makefile
config.status: creating config.h
config.status: executing default commands
\end{sphinxVerbatim}
\begin{itemize}
\item {} 
Configure completed

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
rishi@rishi\PYGZhy{}VirtualBox:\PYGZti{}/build\PYGZus{}glibc\PYGZdl{} ls
bits  config.h  config.log  config.make  config.status  Makefile
\end{sphinxVerbatim}


\subsection{Compliing}
\label{\detokenize{03_glibc:compliing}}\begin{itemize}
\item {} 
Let us run the \sphinxcode{make} command now.

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
rishi@rishi\PYGZhy{}VirtualBox:\PYGZti{}/build\PYGZus{}glibc\PYGZdl{} make \PYGZhy{}j 16
make \PYGZhy{}r PARALLELMFLAGS=\PYGZdq{}\PYGZdq{} \PYGZhy{}C ../glibc\PYGZhy{}2.24 objdir={}`pwd{}` all
make[1]: Entering directory \PYGZsq{}/home/rishi/glibc\PYGZhy{}2.24\PYGZsq{}
LC\PYGZus{}ALL=C gawk \PYGZhy{}f scripts/sysd\PYGZhy{}rules.awk \PYGZgt{} /home/rishi/build\PYGZus{}glibc/sysd\PYGZhy{}rulesT \PYGZbs{}



rishi@rishi\PYGZhy{}VirtualBox:\PYGZti{}/build\PYGZus{}glibc\PYGZdl{} ls
bits  config.h  config.log  config.make  config.status  Makefile
rishi@rishi\PYGZhy{}VirtualBox:\PYGZti{}/build\PYGZus{}glibc\PYGZdl{}
rishi@rishi\PYGZhy{}VirtualBox:\PYGZti{}/build\PYGZus{}glibc\PYGZdl{}
rishi@rishi\PYGZhy{}VirtualBox:\PYGZti{}/build\PYGZus{}glibc\PYGZdl{}



rishi@rishi\PYGZhy{}VirtualBox:\PYGZti{}/build\PYGZus{}glibc\PYGZdl{} make \PYGZhy{}j 16
make \PYGZhy{}r PARALLELMFLAGS=\PYGZdq{}\PYGZdq{} \PYGZhy{}C ../glibc\PYGZhy{}2.24 objdir={}`pwd{}` all
make[1]: Entering directory \PYGZsq{}/home/rishi/glibc\PYGZhy{}2.24\PYGZsq{}
LC\PYGZus{}ALL=C gawk \PYGZhy{}f scripts/sysd\PYGZhy{}rules.awk \PYGZgt{} /home/rishi/build\PYGZus{}glibc/sysd\PYGZhy{}rulesT \PYGZbs{}

      \PYGZgt{}\PYGZgt{}\PYGZgt{}\PYGZgt{}\PYGZgt{}\PYGZgt{}\PYGZgt{}\PYGZgt{}\PYGZgt{}\PYGZgt{}\PYGZgt{}\PYGZgt{}\PYGZgt{}\PYGZgt{}\PYGZgt{}\PYGZgt{}\PYGZgt{}\PYGZgt{}\PYGZgt{}\PYGZgt{}\PYGZgt{}SNIP\PYGZlt{}\PYGZlt{}\PYGZlt{}\PYGZlt{}\PYGZlt{}\PYGZlt{}\PYGZlt{}\PYGZlt{}\PYGZlt{}\PYGZlt{}\PYGZlt{}\PYGZlt{}\PYGZlt{}\PYGZlt{}\PYGZlt{}\PYGZlt{}\PYGZlt{}\PYGZlt{}\PYGZlt{}
gcc \PYGZhy{}nostdlib \PYGZhy{}nostartfiles \PYGZhy{}o /home/rishi/build\PYGZus{}glibc/elf/pldd    \PYGZhy{}Wl,\PYGZhy{}z,combreloc \PYGZhy{}Wl,\PYGZhy{}z,relro \PYGZhy{}Wl,\PYGZhy{}\PYGZhy{}hash\PYGZhy{}style=both /home/rishi/build\PYGZus{}glibc/csu/crt1.o /home/rishi/build\PYGZus{}glibc/csu/crti.o {}`gcc  \PYGZhy{}\PYGZhy{}print\PYGZhy{}file\PYGZhy{}name=crtbegin.o{}` /home/rishi/build\PYGZus{}glibc/elf/pldd.o /home/rishi/build\PYGZus{}glibc/elf/xmalloc.o  \PYGZhy{}Wl,\PYGZhy{}dynamic\PYGZhy{}linker=/home/rishi/install\PYGZus{}glibc/lib/ld\PYGZhy{}linux\PYGZhy{}x86\PYGZhy{}64.so.2 \PYGZhy{}Wl,\PYGZhy{}rpath\PYGZhy{}link=/home/rishi/build\PYGZus{}glibc:/home/rishi/build\PYGZus{}glibc/math:/home/rishi/build\PYGZus{}glibc/elf:/home/rishi/build\PYGZus{}glibc/dlfcn:/home/rishi/build\PYGZus{}glibc/nss:/home/rishi/build\PYGZus{}glibc/nis:/home/rishi/build\PYGZus{}glibc/rt:/home/rishi/build\PYGZus{}glibc/resolv:/home/rishi/build\PYGZus{}glibc/crypt:/home/rishi/build\PYGZus{}glibc/mathvec:/home/rishi/build\PYGZus{}glibc/nptl /home/rishi/build\PYGZus{}glibc/libc.so.6 /home/rishi/build\PYGZus{}glibc/libc\PYGZus{}nonshared.a \PYGZhy{}Wl,\PYGZhy{}\PYGZhy{}as\PYGZhy{}needed /home/rishi/build\PYGZus{}glibc/elf/ld.so \PYGZhy{}Wl,\PYGZhy{}\PYGZhy{}no\PYGZhy{}as\PYGZhy{}needed \PYGZhy{}lgcc  {}`gcc  \PYGZhy{}\PYGZhy{}print\PYGZhy{}file\PYGZhy{}name=crtend.o{}` /home/rishi/build\PYGZus{}glibc/csu/crtn.o
make[2]: Leaving directory \PYGZsq{}/home/rishi/glibc\PYGZhy{}2.24/elf\PYGZsq{}
make[1]: Leaving directory \PYGZsq{}/home/rishi/glibc\PYGZhy{}2.24\PYGZsq{}
\end{sphinxVerbatim}
\begin{itemize}
\item {} 
Make runs successfully.

\item {} 
Let us check the \sphinxcode{install\_glibc} directory. It has nothing in it.

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} ls ../install\PYGZus{}glibc/
\end{sphinxVerbatim}
\begin{itemize}
\item {} 
Let us run the \sphinxcode{make install} command.

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} make install
LC\PYGZus{}ALL=C; export LC\PYGZus{}ALL; \PYGZbs{}
make \PYGZhy{}r PARALLELMFLAGS=\PYGZdq{}\PYGZdq{} \PYGZhy{}C ../glibc\PYGZhy{}2.24 objdir={}`pwd{}` install
make[1]: Entering directory \PYGZsq{}/home/rishi/glibc\PYGZhy{}2.24\PYGZsq{}
make  subdir=csu \PYGZhy{}C csu ..=../ subdir\PYGZus{}lib
make[2]: Entering directory \PYGZsq{}/home/rishi/glibc\PYGZhy{}2.24/csu\PYGZsq{}
make[2]: Leaving directory \PYGZsq{}/home/rishi/glibc\PYGZhy{}

\PYGZgt{}\PYGZgt{}\PYGZgt{}\PYGZgt{}\PYGZgt{}\PYGZgt{}\PYGZgt{}\PYGZgt{}\PYGZgt{}\PYGZgt{}\PYGZgt{}SNIP\PYGZlt{}\PYGZlt{}\PYGZlt{}\PYGZlt{}\PYGZlt{}\PYGZlt{}\PYGZlt{}\PYGZlt{}\PYGZlt{}\PYGZlt{}\PYGZlt{}\PYGZlt{}\PYGZlt{}\PYGZlt{}\PYGZlt{}

 \PYGZhy{}f /home/rishi/build\PYGZus{}glibc/elf/symlink.list
 test ! \PYGZhy{}x /home/rishi/build\PYGZus{}glibc/elf/ldconfig \textbar{}\textbar{} LC\PYGZus{}ALL=C \PYGZbs{}
   /home/rishi/build\PYGZus{}glibc/elf/ldconfig  \PYGZbs{}
            /home/rishi/install\PYGZus{}glibc/lib /home/rishi/install\PYGZus{}glibc/lib
            /home/rishi/build\PYGZus{}glibc/elf/ldconfig: Warning: ignoring configuration file that cannot be opened: /home/rishi/install\PYGZus{}glibc/etc/ld.so.conf: No such file or directory
            make[1]: Leaving directory \PYGZsq{}/home/rishi/glibc\PYGZhy{}2.24\PYGZsq{}
\end{sphinxVerbatim}


\subsection{Install}
\label{\detokenize{03_glibc:install}}\begin{itemize}
\item {} 
Let us now check the \sphinxcode{install\_glibc} directory. It has the required files of the new compiled library.

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
rishi@rishi\PYGZhy{}VirtualBox:\PYGZti{}/build\PYGZus{}glibc\PYGZdl{} ls ../install\PYGZus{}glibc/
bin  etc  include  lib  libexec  sbin
\end{sphinxVerbatim}


\section{Using the new library}
\label{\detokenize{03_glibc:using-the-new-library}}
Let us now use the above library to link and run our code. We will add a new
function to the \sphinxcode{glibc}, change the behaviour of a function in glibc and use the
new function and call the changed function.

This will give us a good understanding of how to compile and link with the new
library.

Here is the code for adding some changes to the glibc code. See the file
\sphinxcode{glibc-2.24/stdlib/div.c} and \sphinxcode{glibc-2.24/include/stdlib.h}.

Here is the diff


\subsection{\sphinxstyleliteralintitle{glibc-2.24/stdlib/div.c}}
\label{\detokenize{03_glibc:glibc-2-24-stdlib-div-c}}\begin{itemize}
\item {} 
Here we have added a function \sphinxcode{my\_div} which just returns -1 on invokation
and have changed the way the function div behaves. Now when we will pass 99 and
99 to div it will return 100 and 100. Read the default behaviour in the man
pages.

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} diff glibc\PYGZhy{}2.24/stdlib/div.c temp/glibc\PYGZhy{}2.24/stdlib/div.c
51d50
\PYGZlt{} \PYGZsh{}include \PYGZlt{}stdio.h\PYGZgt{}
59,64d57
\PYGZlt{}   if (numer == 99 \PYGZam{}\PYGZam{} denom == 99) \PYGZob{}
\PYGZlt{}   printf (\PYGZdq{}\PYGZbs{}nValues are 99 and 99\PYGZdq{});
\PYGZlt{}   result.quot = 100;
\PYGZlt{}   result.rem = 100;
\PYGZlt{}   return result;
\PYGZlt{}   \PYGZcb{}
69,74d61
\PYGZlt{} \PYGZcb{}
\PYGZlt{}
\PYGZlt{}
\PYGZlt{} int my\PYGZus{}div(void) \PYGZob{}
\PYGZlt{}   printf(\PYGZdq{}\PYGZbs{}n\PYGZbs{}nCalling my\PYGZus{}div() function.\PYGZdq{});
\PYGZlt{}   return \PYGZhy{}1;
\end{sphinxVerbatim}
\begin{itemize}
\item {} 
Here is the declaration of the new function.

\end{itemize}


\subsection{\sphinxstyleliteralintitle{glibc-2.24/stdlib/stdlib.h}}
\label{\detokenize{03_glibc:glibc-2-24-stdlib-stdlib-h}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} diff glibc\PYGZhy{}2.24/stdlib/stdlib.h temp/glibc\PYGZhy{}2.24/stdlib/stdlib.h
753,754d752
\PYGZlt{}
\PYGZlt{} extern int my\PYGZus{}div(void);
\end{sphinxVerbatim}
\begin{itemize}
\item {} 
Here is the code which calls the functions.

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}stdio.h\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}stdlib.h\PYGZgt{}}


\PYG{k+kt}{int} \PYG{n+nf}{main} \PYG{p}{(}\PYG{p}{)} \PYG{p}{\PYGZob{}}

	\PYG{k+kt}{div\PYGZus{}t} \PYG{n}{result} \PYG{o}{=} \PYG{n}{div}\PYG{p}{(}\PYG{l+m+mi}{99}\PYG{p}{,} \PYG{l+m+mi}{99}\PYG{p}{)}\PYG{p}{;}
	\PYG{k+kt}{int} \PYG{n}{x} \PYG{o}{=} \PYG{n}{my\PYGZus{}div}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

	\PYG{n}{printf} \PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{Quotient \PYGZpc{}d Remainder \PYGZpc{}d}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{result}\PYG{p}{.}\PYG{n}{quot}\PYG{p}{,} \PYG{n}{result}\PYG{p}{.}\PYG{n}{rem}\PYG{p}{)}\PYG{p}{;}
	\PYG{k}{return} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}
\begin{itemize}
\item {} 
Here is the \sphinxcode{Makefile} which will be used to compile the program.

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n+nv}{TARGET} \PYG{o}{=} div
\PYG{n+nv}{OBJ} \PYG{o}{=} \PYG{k}{\PYGZdl{}(}TARGET\PYG{k}{)}.o
\PYG{n+nv}{SRC} \PYG{o}{=} \PYG{k}{\PYGZdl{}(}TARGET\PYG{k}{)}.c
\PYG{n+nv}{CC} \PYG{o}{=} gcc
\PYG{n+nv}{CFLAGS} \PYG{o}{=} \PYGZhy{}g
\PYG{n+nv}{LDFLAGS} \PYG{o}{=} \PYGZhy{}nostdlib \PYGZhy{}nostartfiles \PYGZhy{}static
\PYG{n+nv}{GLIBCDIR} \PYG{o}{=} /home/rishi/install\PYGZus{}glibc/lib/
\PYG{n+nv}{STARTFILES} \PYG{o}{=} \PYG{k}{\PYGZdl{}(}GLIBCDIR\PYG{k}{)}/crt1.o \PYG{k}{\PYGZdl{}(}GLIBCDIR\PYG{k}{)}/crti.o \PYG{l+s+sb}{{}`}gcc \PYGZhy{}\PYGZhy{}print\PYGZhy{}file\PYGZhy{}name\PYG{o}{=}crtbegin.o\PYG{l+s+sb}{{}`}
\PYG{n+nv}{ENDFILES} \PYG{o}{=} \PYG{l+s+sb}{{}`}gcc \PYGZhy{}\PYGZhy{}print\PYGZhy{}file\PYGZhy{}name\PYG{o}{=}crtend.o\PYG{l+s+sb}{{}`} \PYG{k}{\PYGZdl{}(}GLIBCDIR\PYG{k}{)}/crtn.o
\PYG{n+nv}{LIBGROUP} \PYG{o}{=} \PYGZhy{}Wl,\PYGZhy{}\PYGZhy{}start\PYGZhy{}group \PYG{k}{\PYGZdl{}(}GLIBCDIR\PYG{k}{)}/libc.a \PYGZhy{}lgcc \PYGZhy{}lgcc\PYGZus{}eh \PYGZhy{}Wl,\PYGZhy{}\PYGZhy{}end\PYGZhy{}group
\PYG{n+nv}{INCDIR} \PYG{o}{=} /home/rishi/install\PYGZus{}glibc/include

\PYG{n+nf}{\PYGZdl{}(TARGET)}\PYG{o}{:} \PYG{k}{\PYGZdl{}(}\PYG{n+nv}{OBJ}\PYG{k}{)}
	\PYG{k}{\PYGZdl{}(}CC\PYG{k}{)} \PYG{k}{\PYGZdl{}(}LDFLAGS\PYG{k}{)} \PYGZhy{}o \PYG{n+nv}{\PYGZdl{}@} \PYG{k}{\PYGZdl{}(}STARTFILES\PYG{k}{)} \PYGZdl{}\PYGZca{} \PYG{k}{\PYGZdl{}(}LIBGROUP\PYG{k}{)} \PYG{k}{\PYGZdl{}(}ENDFILES\PYG{k}{)} 

\PYG{n+nf}{\PYGZdl{}(OBJ)}\PYG{o}{:} \PYG{k}{\PYGZdl{}(}\PYG{n+nv}{SRC}\PYG{k}{)}
	\PYG{k}{\PYGZdl{}(}CC\PYG{k}{)} \PYG{k}{\PYGZdl{}(}CFLAGS\PYG{k}{)} \PYGZhy{}c \PYGZdl{}\PYGZca{} \PYGZhy{}I \PYG{l+s+sb}{{}`}gcc \PYGZhy{}\PYGZhy{}print\PYGZhy{}file\PYGZhy{}name\PYG{o}{=}include\PYG{l+s+sb}{{}`} \PYGZhy{}I \PYG{k}{\PYGZdl{}(}INCDIR\PYG{k}{)}

\PYG{n+nf}{clean}\PYG{o}{:}
	rm \PYGZhy{}f *.o *.\PYGZti{} \PYG{k}{\PYGZdl{}(}TARGET\PYG{k}{)}
	rm test.c.*
	rm a.out


\PYG{c}{\PYGZsh{} https://stackoverflow.com/questions/10763394/how\PYGZhy{}to\PYGZhy{}build\PYGZhy{}a\PYGZhy{}c\PYGZhy{}program\PYGZhy{}using\PYGZhy{}a\PYGZhy{}custom\PYGZhy{}version\PYGZhy{}of\PYGZhy{}glibc\PYGZhy{}and\PYGZhy{}static\PYGZhy{}linking/10772056\PYGZsh{}10772056}
\end{sphinxVerbatim}
\begin{itemize}
\item {} 
Run the \sphinxcode{make} command.

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} make
gcc \PYGZhy{}g \PYGZhy{}c div.c \PYGZhy{}I {}`gcc \PYGZhy{}\PYGZhy{}print\PYGZhy{}file\PYGZhy{}name=include{}` \PYGZhy{}I /home/rishi/install\PYGZus{}glibc/include
gcc \PYGZhy{}nostdlib \PYGZhy{}nostartfiles \PYGZhy{}static \PYGZhy{}o div /home/rishi/install\PYGZus{}glibc/lib//crt1.o /home/rishi/install\PYGZus{}glibc/lib//crti.o {}`gcc \PYGZhy{}\PYGZhy{}print\PYGZhy{}file\PYGZhy{}name=crtbegin.o{}` div.o \PYGZhy{}Wl,\PYGZhy{}\PYGZhy{}start\PYGZhy{}group /home/rishi/install\PYGZus{}glibc/lib//libc.a \PYGZhy{}lgcc \PYGZhy{}lgcc\PYGZus{}eh \PYGZhy{}Wl,\PYGZhy{}\PYGZhy{}end\PYGZhy{}group {}`gcc \PYGZhy{}\PYGZhy{}print\PYGZhy{}file\PYGZhy{}name=crtend.o{}` /home/rishi/install\PYGZus{}glibc/lib//crtn.o
\end{sphinxVerbatim}
\begin{itemize}
\item {} 
Run the statically linked code

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} ./div

Values are 99 and 99

Calling my\PYGZus{}div() function.

Quotient 100 Remainder 100
\end{sphinxVerbatim}
\begin{itemize}
\item {} 
See the size of the staticically linked code. The huge size is due to static linking. We will now link it dynamically and then see the size.

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} ls \PYGZhy{}lh div
\PYGZhy{}rwxrwxr\PYGZhy{}x 1 rishi rishi 3.3M Jan 29 20:00 div
\end{sphinxVerbatim}
\begin{itemize}
\item {} 
Run the dynamically linked code.

\end{itemize}

\begin{sphinxadmonition}{note}{Todo}

Link it dynamically.
\end{sphinxadmonition}

\begin{sphinxadmonition}{error}{Error:}
Unable to do it dynamically.
\end{sphinxadmonition}
\begin{itemize}
\item {} 
See the sizes of the files

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
rishi@rishi\PYGZhy{}VirtualBox:\PYGZti{}/test\PYGZus{}code\PYGZdl{} ls \PYGZhy{}l dynamic\PYGZhy{}test static\PYGZhy{}test
\PYGZhy{}rwxrwxr\PYGZhy{}x  1 rishi rishi   8600 Jan 29 12:13 dynamic\PYGZhy{}test
\PYGZhy{}rwxrwxr\PYGZhy{}x  1 rishi rishi 909048 Jan 29 12:13 static\PYGZhy{}test
\end{sphinxVerbatim}

\begin{sphinxadmonition}{note}{Todo}

Link it dynamically.
\end{sphinxadmonition}
\begin{itemize}
\item {} 
Check the file type of the executables.

\end{itemize}

\begin{sphinxadmonition}{note}{Todo}

correct the following.
\end{sphinxadmonition}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
rishi@rishi\PYGZhy{}VirtualBox:\PYGZti{}/test\PYGZus{}code\PYGZdl{} file static\PYGZhy{}test
static\PYGZhy{}test: ELF 64\PYGZhy{}bit LSB executable, x86\PYGZhy{}64, version 1 (GNU/Linux), statically linked, for GNU/Linux 2.6.32, BuildID[sha1]=866f4fe367915159ae62cc80a0ae614059d67153, not stripped
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
rishi@rishi\PYGZhy{}VirtualBox:\PYGZti{}/test\PYGZus{}code\PYGZdl{} file dynamic\PYGZhy{}test
dynamic\PYGZhy{}test: ELF 64\PYGZhy{}bit LSB executable, x86\PYGZhy{}64, version 1 (SYSV), dynamically linked, interpreter /home/rishi/install\PYGZus{}glibc/lib/ld\PYGZhy{}linux\PYGZhy{}x86\PYGZhy{}64.so.2, for GNU/Linux 2.6.32, BuildID[sha1]=c0f8ac9a77a879e6adc855333d6bc88c5078ffd3, not stripped
\end{sphinxVerbatim}


\section{Conclusion}
\label{\detokenize{03_glibc:conclusion}}
In this chapter we have see pretty important things with respect to using glibc. We have see where to find glibc, how to dwnload, extract, make changes and compile the glibc library in your system.

Doing all the steps hands-on will enable you understand the whole workflow more clearly ann will thus improve your understanding of systems.


\chapter{How Is a System Call Called On x86\_64 architecture from User Space}
\label{\detokenize{05_calling_system_calls:how-is-a-system-call-called-on-x86-64-architecture-from-user-space}}\label{\detokenize{05_calling_system_calls::doc}}
There are three parts to calling a system call.
\begin{enumerate}
\item {} 
Setting up the arguements to be passed to the kernel space.

\item {} 
Call the system call using the \sphinxcode{syscall} assembly instruction.

\item {} 
Get back the return value.

\end{enumerate}

In the sections below we will see each of them in detail.


\section{Setting Up Arguements}
\label{\detokenize{05_calling_system_calls:setting-up-arguements}}
\begin{sphinxadmonition}{note}{Note:}
The following text is copied verbatim from the document \sphinxcode{System V
Application Binary Interface AMD64 Architecture Processor 57 Supplement
Draft Version 0.99.6}, Section \sphinxcode{AMD64 Linux Kernel Conventions}
\end{sphinxadmonition}

\begin{sphinxadmonition}{note}{Todo}

Check if we are infringing copyright here.
\end{sphinxadmonition}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Calling} \PYG{n}{Conventions}

\PYG{n}{The} \PYG{n}{Linux} \PYG{n}{AMD64} \PYG{n}{kernel} \PYG{n}{uses} \PYG{n}{internally} \PYG{n}{the} \PYG{n}{same} \PYG{n}{calling} \PYG{n}{conventions} \PYG{k}{as} \PYG{n}{user}\PYG{o}{\PYGZhy{}}
\PYG{n}{level} \PYG{n}{applications} \PYG{p}{(}\PYG{n}{see} \PYG{n}{section} \PYG{l+m+mf}{3.2}\PYG{o}{.}\PYG{l+m+mi}{3} \PYG{k}{for} \PYG{n}{details}\PYG{p}{)}\PYG{o}{.} \PYG{n}{User}\PYG{o}{\PYGZhy{}}\PYG{n}{level} \PYG{n}{applications} \PYG{n}{that} \PYG{n}{like}
\PYG{n}{to} \PYG{n}{call} \PYG{n}{system} \PYG{n}{calls} \PYG{n}{should} \PYG{n}{use} \PYG{n}{the} \PYG{n}{functions} \PYG{k+kn}{from} \PYG{n+nn}{the} \PYG{n}{C} \PYG{n}{library}\PYG{o}{.} \PYG{n}{The} \PYG{n}{interface}
\PYG{n}{between} \PYG{n}{the} \PYG{n}{C} \PYG{n}{library} \PYG{o+ow}{and} \PYG{n}{the} \PYG{n}{Linux} \PYG{n}{kernel} \PYG{o+ow}{is} \PYG{n}{the} \PYG{n}{same} \PYG{k}{as} \PYG{k}{for} \PYG{n}{the} \PYG{n}{user}\PYG{o}{\PYGZhy{}}\PYG{n}{level} \PYG{n}{appli}\PYG{o}{\PYGZhy{}}
\PYG{n}{cations} \PYG{k}{with} \PYG{n}{the} \PYG{n}{following} \PYG{n}{differences}\PYG{p}{:}

\PYG{l+m+mf}{1.} \PYG{n}{User}\PYG{o}{\PYGZhy{}}\PYG{n}{level} \PYG{n}{applications} \PYG{n}{use} \PYG{k}{as} \PYG{n}{integer} \PYG{n}{registers} \PYG{k}{for} \PYG{n}{passing} \PYG{n}{the} \PYG{n}{sequence}
\PYG{o}{\PYGZpc{}}\PYG{n}{rdi}\PYG{p}{,} \PYG{o}{\PYGZpc{}}\PYG{n}{rsi}\PYG{p}{,} \PYG{o}{\PYGZpc{}}\PYG{n}{rdx}\PYG{p}{,} \PYG{o}{\PYGZpc{}}\PYG{n}{rcx}\PYG{p}{,} \PYG{o}{\PYGZpc{}}\PYG{n}{r8} \PYG{o+ow}{and} \PYG{o}{\PYGZpc{}}\PYG{n}{r9}\PYG{o}{.} \PYG{n}{The} \PYG{n}{kernel} \PYG{n}{interface} \PYG{n}{uses} \PYG{o}{\PYGZpc{}}\PYG{n}{rdi}\PYG{p}{,}
\PYG{o}{\PYGZpc{}}\PYG{n}{rsi}\PYG{p}{,} \PYG{o}{\PYGZpc{}}\PYG{n}{rdx}\PYG{p}{,} \PYG{o}{\PYGZpc{}}\PYG{n}{r10}\PYG{p}{,} \PYG{o}{\PYGZpc{}}\PYG{n}{r8} \PYG{o+ow}{and} \PYG{o}{\PYGZpc{}}\PYG{n}{r9}\PYG{o}{.}
\PYG{l+m+mf}{2.} \PYG{n}{A} \PYG{n}{system}\PYG{o}{\PYGZhy{}}\PYG{n}{call} \PYG{o+ow}{is} \PYG{n}{done} \PYG{n}{via} \PYG{n}{the} \PYG{n}{syscall} \PYG{n}{instruction}\PYG{o}{.} \PYG{n}{The} \PYG{n}{kernel} \PYG{n}{destroys}
\PYG{n}{registers} \PYG{o}{\PYGZpc{}}\PYG{n}{rcx} \PYG{o+ow}{and} \PYG{o}{\PYGZpc{}}\PYG{n}{r11}\PYG{o}{.}
\PYG{l+m+mf}{3.} \PYG{n}{The} \PYG{n}{number} \PYG{n}{of} \PYG{n}{the} \PYG{n}{syscall} \PYG{n}{has} \PYG{n}{to} \PYG{n}{be} \PYG{n}{passed} \PYG{o+ow}{in} \PYG{n}{register} \PYG{o}{\PYGZpc{}}\PYG{n}{rax}\PYG{o}{.}
\PYG{l+m+mf}{4.} \PYG{n}{System}\PYG{o}{\PYGZhy{}}\PYG{n}{calls} \PYG{n}{are} \PYG{n}{limited} \PYG{n}{to} \PYG{n}{six} \PYG{n}{arguments}\PYG{p}{,} \PYG{n}{no} \PYG{n}{argument} \PYG{o+ow}{is} \PYG{n}{passed} \PYG{n}{directly} \PYG{n}{on}
\PYG{n}{the} \PYG{n}{stack}\PYG{o}{.}
\PYG{l+m+mf}{5.} \PYG{n}{Returning} \PYG{k+kn}{from} \PYG{n+nn}{the} \PYG{n}{syscall}\PYG{p}{,} \PYG{n}{register} \PYG{o}{\PYGZpc{}}\PYG{n}{rax} \PYG{n}{contains} \PYG{n}{the} \PYG{n}{result} \PYG{n}{of} \PYG{n}{the}
\PYG{n}{system}\PYG{o}{\PYGZhy{}}\PYG{n}{call}\PYG{o}{.} \PYG{n}{A} \PYG{n}{value} \PYG{o+ow}{in} \PYG{n}{the} \PYG{n+nb}{range} \PYG{n}{between} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{4095} \PYG{o+ow}{and} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1} \PYG{n}{indicates} \PYG{n}{an} \PYG{n}{error}\PYG{p}{,}
\PYG{n}{it} \PYG{o+ow}{is} \PYG{o}{\PYGZhy{}}\PYG{n}{errno}\PYG{o}{.}
\PYG{l+m+mf}{6.} \PYG{n}{Only} \PYG{n}{values} \PYG{n}{of} \PYG{k}{class} \PYG{n+nc}{INTEGER} \PYG{o+ow}{or} \PYG{k}{class} \PYG{n+nc}{MEMORY} \PYG{n}{are} \PYG{n}{passed} \PYG{n}{to} \PYG{n}{the} \PYG{n}{kernel}\PYG{o}{.}
\end{sphinxVerbatim}

See the \sphinxcode{System V Application Binary Interface AMD64 Architecture Processor
Supplement Draft Version 0.99.6}. Section \sphinxcode{AMD64 Linux Kernel Conventions}
for the details.


\subsection{Reiterating The Above Again}
\label{\detokenize{05_calling_system_calls:reiterating-the-above-again}}
Hence when we have called any function in user space we will have the following
state of the registers when we are in the called function.


\begin{threeparttable}
\capstart\caption{``Arguements Passing In Linux''}\label{\detokenize{05_calling_system_calls:id1}}
\noindent\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
\sphinxstylethead{\relax 
Register
\unskip}\relax &\sphinxstylethead{\relax 
Argument User Space
\unskip}\relax &\sphinxstylethead{\relax 
Argument Kernel Space
\unskip}\relax \\
\hline
\%rax
&
Not Used
&
System Call Number
\\
\hline
\%rdi
&
Arguement 1
&
Arguement 1
\\
\hline
\%rsi
&
Arguement 2
&
Arguement 2
\\
\hline
\%rdx
&
Arguement 3
&
Arguement 3
\\
\hline
\%r10
&
Not Used
&
Arguement 4
\\
\hline
\%r8
&
Arguement 5
&
Arguement 5
\\
\hline
\%r9
&
Arguement 6
&
Arguement 6
\\
\hline
\%rcx
&
Arguement 4
&
Destroyed
\\
\hline
\%r11
&
Not Used
&
Destroyed
\\
\hline\end{tabulary}

\end{threeparttable}


\begin{sphinxadmonition}{note}{Note:}
This table summarizes the differences when a function call is made in the user space, and when a system call is made.
This will be more clear in coming texts. Right now make a note of it
\end{sphinxadmonition}


\subsection{Passing arguements}
\label{\detokenize{05_calling_system_calls:passing-arguements}}\begin{enumerate}
\item {} 
Arguements are passed in the registers. The called function then uses the register to get the arguements.

\item {} 
The arguements are passed in the following sequence \sphinxcode{\%rdi, \%rsi, \%rdx, \%r10, \%r8 and \%r9.}

\item {} 
Number of arguements are limited to \sphinxcode{six}, no arguements will be passed on the stack.

\item {} 
Only values of class INTEGER or class MEMORY are passed to the kernel.

\item {} 
Class \sphinxcode{INTEGER} This class consists of integral types that fit into one of the general
purpose registers.

\item {} 
Class \sphinxcode{MEMORY} This class consists of types that will be passed and returned in mem-
ory via the stack. These will mostly be strings or memory buffer. For example in \sphinxcode{write()} system call, the first parameter is \sphinxcode{fd} which is of class \sphinxcode{INTEGER} while the second argument is the \sphinxcode{buffer} which has the data to be written in the file, the class will be \sphinxcode{MEMORY} over here. The third parameter which is the count - again has the class as \sphinxcode{INTEGER}.

\end{enumerate}

\begin{sphinxadmonition}{note}{Note:}
The above information is sourced from AMD64 Architecture Processor Supplement Draft Version 0.99.6
\end{sphinxadmonition}


\section{Calling the System Call}
\label{\detokenize{05_calling_system_calls:calling-the-system-call}}\begin{enumerate}
\item {} 
A system-call is done via the \sphinxcode{syscall} assembly instruction. The kernel destroys registers \sphinxcode{\%rcx} and \sphinxcode{\%r11}.

\item {} 
The number of the syscall has to be passed in register \sphinxcode{\%rax}.

\end{enumerate}


\section{Retrieving the Return Value}
\label{\detokenize{05_calling_system_calls:retrieving-the-return-value}}\begin{enumerate}
\item {} 
Returning from the \sphinxcode{syscall}, register \sphinxcode{\%rax} contains the result of the
system-call. A value in the range between \sphinxcode{-4095} and \sphinxcode{-1} indicates an error, it
is \sphinxcode{-errno}.

\end{enumerate}


\chapter{Setting Up Arguments}
\label{\detokenize{06_setting_up_arguements:setting-up-arguments}}\label{\detokenize{06_setting_up_arguements::doc}}

\section{Introduction}
\label{\detokenize{06_setting_up_arguements:introduction}}
In the above section we have see the theory part related to passing arguements
to the system call interface of the kernel.  Now we will see some assignements
related to it.

We will see if how the above concepts being implemented in actual code. By this
time we know that the we need to link the code to the \sphinxcode{glibc} in order to use
the system calls. In the following sections we will see this

We will do it in three different ways.
\begin{enumerate}
\item {} 
Walk through \sphinxcode{open} system call in \sphinxcode{glibc} library.

\item {} 
See it using debugger.

\item {} 
Use \sphinxcode{ptrace} system call and see the state of the registers. Code related to this can be found in the appendix.

\end{enumerate}


\section{Walk through \sphinxstyleliteralintitle{open} system call in \sphinxstyleliteralintitle{glibc}}
\label{\detokenize{06_setting_up_arguements:walk-through-open-system-call-in-glibc}}
In this assignment we will download the source code of \sphinxcode{glibc} and then walk through the code
to find out where exactly the code is calling the \sphinxcode{syscall} assembly instruction and where is
it moving the arguements to the registers.

We will do this with \sphinxcode{open} system call and \sphinxcode{write} system calls.

\begin{sphinxadmonition}{note}{Note:}
If you have not understood above concepts. Do not worry, keep reading
on and then re-read the whole thing once more.
\end{sphinxadmonition}


\subsection{How \sphinxstyleliteralintitle{open()} system call is called using \sphinxstyleliteralintitle{glibc}}
\label{\detokenize{06_setting_up_arguements:how-open-system-call-is-called-using-glibc}}\begin{enumerate}
\item {} 
All the above theory should match with the code which is written in \sphinxcode{glibc}.

\item {} 
We will now read the code in the \sphinxcode{glibc} to find out if the theory matches
what is written in the code.

\item {} 
We will also do some assignments to get a better understanding of the above theory.

\item {} 
Now the question is \sphinxcode{open} system call - how will it turn to a \sphinxcode{syscall}
instruction.

\item {} 
Now we need to find out what happens to the \sphinxcode{open} system call when compiled.

\item {} 
File where sys call numbers are mentioned
\sphinxcode{/usr/include/x86\_64-linux-gnu/asm/unistd\_64.h}

\item {} 
File where \sphinxcode{SYS\_write} maps to \sphinxcode{NR\_Write}
\sphinxcode{/usr/include/x86\_64-linux-gnu/bits/syscall.h}

\item {} 
From the objdump we saw that \sphinxcode{\_\_libc\_open} was called. This called
\sphinxcode{\_\_open\_nocancel} and it had a \sphinxcode{syscall} instruction. It means that the
path to the kernel is in this function.

\item {} 
See the \sphinxcode{object dump}, offset \sphinxcode{433e0e}. This dump is taken from a code where we had a
\sphinxcode{open} system call and was compiled.

\end{enumerate}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
0000000000433e09 \PYGZlt{}\PYGZus{}open\PYGZus{}nocancel\PYGZgt{}:
433e09:   b8 02 00 00 00          mov    \PYGZdl{}0x2,\PYGZpc{}eax

433e0e:   0f 05                   syscall        \PYGZlt{}\PYGZlt{}\PYGZlt{}\PYGZlt{}\PYGZlt{}\PYGZlt{}\PYGZlt{}\PYGZlt{}\PYGZlt{}\PYGZlt{}\PYGZlt{}\PYGZlt{}\PYGZlt{}\PYGZlt{}\PYGZlt{}\PYGZlt{}\PYGZlt{}\PYGZlt{}

433e10:   48 3d 01 f0 ff ff       cmp    \PYGZdl{}0xfffffffffffff001,\PYGZpc{}rax
433e16:   0f 83 f4 46 00 00       jae    438510 \PYGZlt{}\PYGZus{}\PYGZus{}syscall\PYGZus{}error\PYGZgt{}
433e1c:   c3                      retq
433e1d:   48 83 ec 08             sub    \PYGZdl{}0x8,\PYGZpc{}rsp
433e21:   e8 ca 2f 00 00          callq  436df0 \PYGZlt{}\PYGZus{}\PYGZus{}libc\PYGZus{}enable\PYGZus{}asynccancel\PYGZgt{}
433e26:   48 89 04 24             mov    \PYGZpc{}rax,(\PYGZpc{}rsp)
433e2a:   b8 02 00 00 00          mov    \PYGZdl{}0x2,\PYGZpc{}eax
433e2f:   0f 05                   syscall
433e31:   48 8b 3c 24             mov    (\PYGZpc{}rsp),\PYGZpc{}rdi
433e35:   48 89 c2                mov    \PYGZpc{}rax,\PYGZpc{}rdx
433e38:   e8 13 30 00 00          callq  436e50 \PYGZlt{}\PYGZus{}\PYGZus{}libc\PYGZus{}disable\PYGZus{}asynccancel\PYGZgt{}
433e3d:   48 89 d0                mov    \PYGZpc{}rdx,\PYGZpc{}rax
433e40:   48 83 c4 08             add    \PYGZdl{}0x8,\PYGZpc{}rsp
433e44:   48 3d 01 f0 ff ff       cmp    \PYGZdl{}0xfffffffffffff001,\PYGZpc{}rax
433e4a:   0f 83 c0 46 00 00       jae    438510 \PYGZlt{}\PYGZus{}\PYGZus{}syscall\PYGZus{}error\PYGZgt{}
433e50:   c3                      retq
433e51:   66 2e 0f 1f 84 00 00    nopw   \PYGZpc{}cs:0x0(\PYGZpc{}rax,\PYGZpc{}rax,1)
433e58:   00 00 00
433e5b:   0f 1f 44 00 00          nopl   0x0(\PYGZpc{}rax,\PYGZpc{}rax,1)
\end{sphinxVerbatim}
\begin{enumerate}
\item {} 
Now, when in glibc-2.3 dir I started finding the code for the function
\sphinxcode{\_\_open\_nocancel} I found this

\item {} 
File is \sphinxcode{sysdeps/unix/sysv/linux/generic/open.c}

\end{enumerate}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{int} \PYG{n}{\PYGZus{}\PYGZus{}open\PYGZus{}nocancel} \PYG{p}{(}\PYG{n}{const} \PYG{n}{char} \PYG{o}{*}\PYG{n}{file}\PYG{p}{,} \PYG{n+nb}{int} \PYG{n}{oflag}\PYG{p}{,} \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{n+nb}{int} \PYG{n}{mode} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}

    \PYG{k}{if} \PYG{p}{(}\PYG{n}{\PYGZus{}\PYGZus{}OPEN\PYGZus{}NEEDS\PYGZus{}MODE} \PYG{p}{(}\PYG{n}{oflag}\PYG{p}{)}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{va\PYGZus{}list} \PYG{n}{arg}\PYG{p}{;}
        \PYG{n}{va\PYGZus{}start} \PYG{p}{(}\PYG{n}{arg}\PYG{p}{,} \PYG{n}{oflag}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{mode} \PYG{o}{=} \PYG{n}{va\PYGZus{}arg} \PYG{p}{(}\PYG{n}{arg}\PYG{p}{,} \PYG{n+nb}{int}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{va\PYGZus{}end} \PYG{p}{(}\PYG{n}{arg}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{k}{return} \PYG{n}{INLINE\PYGZus{}SYSCALL} \PYG{p}{(}\PYG{n}{openat}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{n}{AT\PYGZus{}FDCWD}\PYG{p}{,} \PYG{n}{file}\PYG{p}{,} \PYG{n}{oflag}\PYG{p}{,} \PYG{n}{mode}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}
\begin{enumerate}
\item {} 
So INLINE\_SYSCALL is being called by this function. This is defined in the
file \sphinxcode{glibc-2.3/sysdeps/unix/sysv/linux/x86\_64/sysdep.h}

\end{enumerate}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} define INLINE\PYGZus{}SYSCALL(name, nr, args...) \PYGZbs{}}
    \PYG{p}{(}\PYG{p}{\PYGZob{}}                                          \PYGZbs{}
     \PYG{n}{unsigned} \PYG{n}{long} \PYG{n+nb}{int} \PYG{n}{resultvar} \PYG{o}{=} \PYG{n}{INTERNAL\PYGZus{}SYSCALL} \PYG{p}{(}\PYG{n}{name}\PYG{p}{,} \PYG{p}{,} \PYG{n}{nr}\PYG{p}{,} \PYG{n}{args}\PYG{p}{)}\PYG{p}{;}        \PYGZbs{}
     \PYG{k}{if} \PYG{p}{(}\PYG{n}{\PYGZus{}\PYGZus{}glibc\PYGZus{}unlikely} \PYG{p}{(}\PYG{n}{INTERNAL\PYGZus{}SYSCALL\PYGZus{}ERROR\PYGZus{}P} \PYG{p}{(}\PYG{n}{resultvar}\PYG{p}{,} \PYG{p}{)}\PYG{p}{)}\PYG{p}{)}        \PYGZbs{}
     \PYG{p}{\PYGZob{}}                                       \PYGZbs{}
     \PYG{n}{\PYGZus{}\PYGZus{}set\PYGZus{}errno} \PYG{p}{(}\PYG{n}{INTERNAL\PYGZus{}SYSCALL\PYGZus{}ERRNO} \PYG{p}{(}\PYG{n}{resultvar}\PYG{p}{,} \PYG{p}{)}\PYG{p}{)}\PYG{p}{;}           \PYGZbs{}
     \PYG{n}{resultvar} \PYG{o}{=} \PYG{p}{(}\PYG{n}{unsigned} \PYG{n}{long} \PYG{n+nb}{int}\PYG{p}{)} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{;}                   \PYGZbs{}
     \PYG{p}{\PYGZcb{}}                                       \PYGZbs{}
     \PYG{p}{(}\PYG{n}{long} \PYG{n+nb}{int}\PYG{p}{)} \PYG{n}{resultvar}\PYG{p}{;} \PYG{p}{\PYGZcb{}}\PYG{p}{)}
\end{sphinxVerbatim}
\begin{enumerate}
\item {} 
Thus it calls \sphinxcode{INTERNAL\_SYSCALL} which is defined as

\end{enumerate}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} define INTERNAL\PYGZus{}SYSCALL(name, err, nr, args...) \PYGZbs{}}
  \PYG{n}{INTERNAL\PYGZus{}SYSCALL\PYGZus{}NCS} \PYG{p}{(}\PYG{n}{\PYGZus{}\PYGZus{}NR\PYGZus{}}\PYG{c+c1}{\PYGZsh{}\PYGZsh{}name, err, nr, \PYGZsh{}\PYGZsh{}args)}
\end{sphinxVerbatim}
\begin{enumerate}
\item {} 
Now let us see the \sphinxcode{INTERNAL\_SYSCALL\_NCS} in the file
\sphinxcode{./sysdeps/unix/sysv/linux/x86\_64/sysdep.h} here see the macro
\sphinxcode{INTERNAL\_SYSCALL\_NCS}. This is the exact macro which is calling the
\sphinxcode{syscall} assembly instruction. You can see the \sphinxcode{asm} instructions in the code.

\end{enumerate}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} define INTERNAL\PYGZus{}SYSCALL\PYGZus{}NCS(name, err, nr, args...) \PYGZbs{}}
    \PYG{p}{(}\PYG{p}{\PYGZob{}}                                          \PYGZbs{}
     \PYG{n}{unsigned} \PYG{n}{long} \PYG{n+nb}{int} \PYG{n}{resultvar}\PYG{p}{;}                          \PYGZbs{}
     \PYG{n}{LOAD\PYGZus{}ARGS\PYGZus{}}\PYG{c+c1}{\PYGZsh{}\PYGZsh{}nr (args)                             \PYGZbs{}}
     \PYG{n}{LOAD\PYGZus{}REGS\PYGZus{}}\PYG{c+c1}{\PYGZsh{}\PYGZsh{}nr                                \PYGZbs{}}
     \PYG{n}{asm} \PYG{n}{volatile} \PYG{p}{(}                                \PYGZbs{}
         \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{syscall}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s+s2}{\PYGZdq{}}                                 \PYGZbs{}
         \PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{=a}\PYG{l+s+s2}{\PYGZdq{}} \PYG{p}{(}\PYG{n}{resultvar}\PYG{p}{)}                                \PYGZbs{}
         \PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{0}\PYG{l+s+s2}{\PYGZdq{}} \PYG{p}{(}\PYG{n}{name}\PYG{p}{)} \PYG{n}{ASM\PYGZus{}ARGS\PYGZus{}}\PYG{c+c1}{\PYGZsh{}\PYGZsh{}nr : \PYGZdq{}memory\PYGZdq{}, REGISTERS\PYGZus{}CLOBBERED\PYGZus{}BY\PYGZus{}SYSCALL);   \PYGZbs{}}
     \PYG{p}{(}\PYG{n}{long} \PYG{n+nb}{int}\PYG{p}{)} \PYG{n}{resultvar}\PYG{p}{;} \PYG{p}{\PYGZcb{}}\PYG{p}{)}
\end{sphinxVerbatim}
\begin{enumerate}
\item {} 
Thus here we enter the kernel using the \sphinxcode{syscall} assembly instruction.

\item {} 
Also, we need to figure out how - \sphinxcode{open()} call went to be called as \sphinxcode{\_\_open\_nocancel}

\end{enumerate}

\begin{sphinxadmonition}{note}{Todo}

\sphinxcode{open} call called \sphinxcode{\_\_open\_nocancel}, How.
\end{sphinxadmonition}

\begin{sphinxadmonition}{note}{Todo}

The above section is not very well written, do it.
\end{sphinxadmonition}

\#.  We have redone the whole thing with the \sphinxcode{write} system call in the
appendix. You can see that as well to get more clarity.


\subsection{How is \sphinxstyleliteralintitle{write} system call implemented in \sphinxstyleliteralintitle{glibc}}
\label{\detokenize{06_setting_up_arguements:how-is-write-system-call-implemented-in-glibc}}
\begin{sphinxadmonition}{note}{Todo}

Write this part - do it in the appendix. This will make the paper better organized.
\end{sphinxadmonition}


\section{Check Arguements Using A Debugger}
\label{\detokenize{06_setting_up_arguements:check-arguements-using-a-debugger}}
In the above example we saw how the code calls the \sphinxcode{syscall} instruction to
enter the kernel and call the required functionality.  Write the following code
and compile it with \sphinxcode{gcc -g filename.c}

\sphinxcode{-g} flag adds the debugging information to the execuatable.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}fcntl.h\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}string.h\PYGZgt{}}

\PYG{k+kt}{int} \PYG{n+nf}{main} \PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{k+kt}{char} \PYG{n}{filename}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{non\PYGZus{}existent\PYGZus{}file}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
    \PYG{k+kt}{int} \PYG{n}{fd}\PYG{p}{;}
    \PYG{n}{fd} \PYG{o}{=} \PYG{n}{open} \PYG{p}{(}\PYG{n}{filename}\PYG{p}{,} \PYG{n}{O\PYGZus{}CREAT}\PYG{o}{\textbar{}}\PYG{n}{O\PYGZus{}WRONLY}\PYG{p}{)}\PYG{p}{;}

    \PYG{n}{fd} \PYG{o}{=} \PYG{n}{write} \PYG{p}{(}\PYG{n}{fd}\PYG{p}{,} \PYG{n}{filename}\PYG{p}{,} \PYG{n}{strlen}\PYG{p}{(}\PYG{n}{filename}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{close} \PYG{p}{(}\PYG{n}{fd}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{unlink} \PYG{p}{(}\PYG{n}{filename}\PYG{p}{)}\PYG{p}{;}
    \PYG{k}{return} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}
\begin{itemize}
\item {} 
Once done, run the code in the debugger \sphinxcode{gdb ./a.out}

\item {} 
Set the breakpoint in the call on write \sphinxcode{break write}

\item {} 
According to the calling conventions the register \sphinxcode{\$rdi} should have the
file descriptor. \sphinxcode{\$rdi} should have the string's address and the \sphinxcode{\$rdx}
should have the length of the string.

\item {} 
Using \sphinxcode{print} command will confirm these values.

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
(gdb) b write
Breakpoint 1 at 0x400560
(gdb) r
Starting program: /home/rishi/mydev/books/crash\PYGZus{}book/code\PYGZus{}system\PYGZus{}calls/01/aaa/a.out

Breakpoint 1, write () at ../sysdeps/unix/syscall\PYGZhy{}template.S:81
81  ../sysdeps/unix/syscall\PYGZhy{}template.S: No such file or directory.
(gdb) print \PYGZdl{}rdi
\PYGZdl{}1 = 3
(gdb) print (char *) \PYGZdl{}rsi
\PYGZdl{}2 = 0x7fffffffdeb0 \PYGZdq{}non\PYGZus{}existent\PYGZus{}file\PYGZdq{}
(gdb) print \PYGZdl{}rdx
\PYGZdl{}3 = 17
(gdb)
\end{sphinxVerbatim}


\section{Using \sphinxstyleliteralintitle{ptrace} to see the variables passed}
\label{\detokenize{06_setting_up_arguements:using-ptrace-to-see-the-variables-passed}}
\begin{sphinxadmonition}{note}{Todo}

add code for this. Better to add it as a appendix.
\end{sphinxadmonition}


\chapter{System Call Implementation In the User Space}
\label{\detokenize{06_system_call_implementation:system-call-implementation-in-the-user-space}}\label{\detokenize{06_system_call_implementation::doc}}
There are two ways system calls are being called in the user space. Both of
them will eventually call the \sphinxcode{syscall} instruction but \sphinxcode{glibc} provides a
wrapper around that instruction using a function call.
\begin{itemize}
\item {} \begin{description}
\item[{\sphinxcode{glibc} library call which does the work which needs to be done before}] \leavevmode
calling the \sphinxcode{syscall} instruction.

\end{description}

\item {} 
\sphinxcode{syscall} assembly instruction to enter the priviledged mode. This allows
the process to move to the priviledge mode.

\end{itemize}


\chapter{Calling System Calls}
\label{\detokenize{07_calling_system_calls:calling-system-calls}}\label{\detokenize{07_calling_system_calls::doc}}

\section{Glibc \sphinxstyleliteralintitle{syscall()} interface}
\label{\detokenize{07_calling_system_calls:glibc-syscall-interface}}\begin{enumerate}
\item {} 
There is a library function in \sphinxcode{glibc} named as \sphinxcode{syscall}, you can read
about it in the man pages by the command \sphinxcode{man 2 syscall}.

\item {} 
We already have the code of \sphinxcode{glibc} with us.

\item {} 
See the function in the file
\sphinxcode{glibc-2.23/sysdeps/unix/sysv/linux/x86\_64/syscall.S}

\item {} 
On reading the code you will see that the function is moving the arguement
values to the registers and then calling the assembly instruction \sphinxcode{syscall}.

\item {} 
As \sphinxcode{syscall} here is a user space \sphinxcode{glibc} library function, first the
arguements will be in the registers used for calling user space functions. Once
this is done, as the system call is being called, the arguements will be used
into the registers where the kernel wishes to find the arguments.

\item {} 
Code for \sphinxcode{syscall(2)} library function.

\end{enumerate}

\begin{sphinxadmonition}{note}{Note:}
Remember the note above. As \sphinxcode{syscall} is a function which we called
in user space, the registers are different. We now need to pick and place
the registers in a way that the system call understands it. THis is shown in
the code below.
\end{sphinxadmonition}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
.text

    ENTRY (syscall)
        movq \PYGZpc{}rdi, \PYGZpc{}rax             /* Syscall number \PYGZhy{}\PYGZgt{} rax.  */
        movq \PYGZpc{}rsi, \PYGZpc{}rdi             /* Shift the arg2 to arg1 for syscalls */
        movq \PYGZpc{}rdx, \PYGZpc{}rsi             /* Shift the arg3 to arg2 for syscalls */
        movq \PYGZpc{}rcx, \PYGZpc{}rdx             /* Shift the arg4 to arg3 for syscalls */
        movq \PYGZpc{}r8, \PYGZpc{}r10              /* Shift the arg5 to arg4 for syscalls */
        movq \PYGZpc{}r9, \PYGZpc{}r8               /* Shift the arg6 ro arg5 for syscalls */
        movq 8(\PYGZpc{}rsp),\PYGZpc{}r9            /* Shift the arg7 from the stack to arg6 for syscalls */
        syscall                     /* Do the system call.  */
        cmpq \PYGZdl{}\PYGZhy{}4095, \PYGZpc{}rax           /* Check \PYGZpc{}rax for error. \PYGZpc{}rax has the return value  */
        jae SYSCALL\PYGZus{}ERROR\PYGZus{}LABEL     /* Jump to error handler if error.  */
        ret                         /* Return to caller.  */
    PSEUDO\PYGZus{}END (syscall)
\end{sphinxVerbatim}

\begin{sphinxadmonition}{note}{Todo}

The above code is not getting highlighted, maybe due to the use of
incorrect lexer. See this page \url{http://pygments.org/docs/lexers/} and
hightlight the above code. use code block for this.
\end{sphinxadmonition}


\section{Assembly Instruction for calling system call.}
\label{\detokenize{07_calling_system_calls:assembly-instruction-for-calling-system-call}}
We know now that for calling a system call we just need to set the right
arguements in the register and then call the \sphinxcode{syscall} instruction.

Register \sphinxcode{\%rax} needs the \sphinxcode{system call number}. So where are the \sphinxcode{system
call numbers} defined. Here we can see the \sphinxcode{glibc} code to see the mapping
of the number and the system call. Or you can see this in a header file in the
system's include directory.

System call numbers will never change, if they do there will be a lot of
porting efforts which will need to be done else a lot of applications will
break.

Let us see a excerpt from the file \sphinxcode{/usr/include/x86\_64-linux-gnu/asm/unistd\_64.h}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{}define \PYGZus{}\PYGZus{}NR\PYGZus{}read 0}
\PYG{c+c1}{\PYGZsh{}define \PYGZus{}\PYGZus{}NR\PYGZus{}write 1}
\PYG{c+c1}{\PYGZsh{}define \PYGZus{}\PYGZus{}NR\PYGZus{}open 2}
\PYG{c+c1}{\PYGZsh{}define \PYGZus{}\PYGZus{}NR\PYGZus{}close 3}
\PYG{c+c1}{\PYGZsh{}define \PYGZus{}\PYGZus{}NR\PYGZus{}stat 4}
\end{sphinxVerbatim}

Here you can see that the system calls have numbers associated with them.

Now armed with the knowledge of how to call system calls let us write some
assembly code where we call a system call.

Before doing this excercise let us see the \sphinxcode{write} system call a bit. In the
follwing code we will write \sphinxcode{hello world} on the screen. We will not use
\sphinxcode{printf} for this, rather we will use \sphinxcode{2} (the standard descriptor for
writing to the terminal) and \sphinxcode{write} system call for it.

We need to do this so that we understand our assembly level program a bit better.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}fcntl.h\PYGZgt{}}

\PYG{k+kt}{int} \PYG{n+nf}{main} \PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{n}{write} \PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Hello World}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+m+mi}{11}\PYG{p}{)}\PYG{p}{;}
    \PYG{k}{return} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

You should go through the assembly code of the C file. Use command \sphinxcode{gcc -S
filename.c} This will generate the assembly file with \sphinxcode{.s} extension. If you
go through the assembly code you will see a call to \sphinxcode{write} function. This
function is defined in the \sphinxcode{glibc}. We will see the source of \sphinxcode{write}
system call in sometime. At that time you can refer this and understand it
better.

\begin{sphinxadmonition}{note}{Note:}
When I am compiling the code I can see the assembly code only using the eax register and not rax, why?
\end{sphinxadmonition}

\begin{sphinxadmonition}{note}{Todo}

We should explain the assembly code generated above.
\end{sphinxadmonition}

Now we will do the same using the \sphinxcode{syscall} intergface which the \sphinxcode{glibc} provides.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}unistd.h\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}sys/syscall.h\PYGZgt{}}


\PYG{k+kt}{int} \PYG{n+nf}{main} \PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{n}{syscall} \PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Hello World}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+m+mi}{11}\PYG{p}{)}\PYG{p}{;}
    \PYG{k}{return} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

You should go through the assembly code of the C file. Use command \sphinxcode{gcc -S
filename.c} This will generate the assembly file with \sphinxcode{.s} extension. If you
go through the assembly code you will see a call to \sphinxcode{syscall} function. This
function is defined in the \sphinxcode{glibc}. We will see the source of \sphinxcode{syscall}
system call in sometime. At that time you can refer this and understand it
better.

\begin{sphinxadmonition}{note}{Note:}
When I am compiling the code I can see the assembly code only using the eax register and not rax, why?
\end{sphinxadmonition}

\begin{sphinxadmonition}{note}{Todo}

We should explain the assembly code generated above.
\end{sphinxadmonition}

Now we will do the same in our assembly code.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k}{section} \PYG{n+nv}{.text}
	\PYG{k}{global} \PYG{n+nv}{\PYGZus{}start}
	\PYG{n+nl}{\PYGZus{}start:}                 \PYG{c+c1}{; ELF entry point}
	 \PYG{c+c1}{; 1 is the number for syscall write ().}

    \PYG{n+nf}{mov} \PYG{n+nb}{rax}\PYG{p}{,} \PYG{l+m+mi}{1}             	
    \PYG{c+c1}{; 1 is the STDOUT file descriptor.}

    \PYG{n+nf}{mov} \PYG{n+nb}{rdi}\PYG{p}{,} \PYG{l+m+mi}{1}             	
    
     \PYG{c+c1}{; buffer to be printed.}

    \PYG{n+nf}{mov} \PYG{n+nb}{rsi}\PYG{p}{,} \PYG{n+nv}{message}       	
    
    \PYG{c+c1}{; length of buffer}

    \PYG{n+nf}{mov} \PYG{n+nb}{rdx}\PYG{p}{,} \PYG{p}{[}\PYG{n+nv}{messageLen}\PYG{p}{]}   	

    \PYG{c+c1}{; call the syscall instruction}
    \PYG{n+nf}{syscall}
	
    \PYG{c+c1}{; sys\PYGZus{}exit}
	\PYG{n+nf}{mov} \PYG{n+nb}{rax}\PYG{p}{,} \PYG{l+m+mi}{60}             

    \PYG{c+c1}{; return value is 0}
	\PYG{n+nf}{mov} \PYG{n+nb}{rdi}\PYG{p}{,} \PYG{l+m+mi}{0}              

    \PYG{c+c1}{; call the assembly instruction}
	\PYG{n+nf}{syscall}                  
	
\PYG{k}{section} \PYG{n+nv}{.data}
	\PYG{n+nl}{messageLen:} \PYG{k+kd}{dq} \PYG{n+nv}{message.end}\PYG{o}{\PYGZhy{}}\PYG{n+nv}{message}
	\PYG{n+nl}{message:} \PYG{k+kd}{db} \PYG{l+s}{\PYGZsq{}Hello World\PYGZsq{}}\PYG{p}{,} \PYG{l+m+mi}{10}
\PYG{n+nl}{.end:}
\end{sphinxVerbatim}

Makefile for assembling the code.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n+nf}{all}\PYG{o}{:}
	nasm \PYGZhy{}felf64 hello.asm
	ld hello.o

\PYG{n+nf}{clean}\PYG{o}{:}
	rm \PYGZhy{}rf *.o
	
\end{sphinxVerbatim}


\chapter{Return Values}
\label{\detokenize{08_return_values:return-values}}\label{\detokenize{08_return_values::doc}}

\section{Return Value Status in the register}
\label{\detokenize{08_return_values:return-value-status-in-the-register}}
\begin{sphinxadmonition}{note}{Todo}

add content to show the return values as well and the error codes.
\end{sphinxadmonition}


\section{Conclusion}
\label{\detokenize{08_return_values:conclusion}}
Hence we now know the following stuff

\begin{sphinxadmonition}{note}{Todo}

Write the conclusion.
\end{sphinxadmonition}


\chapter{Walk through \sphinxstyleliteralintitle{write} system call}
\label{\detokenize{11_appendix:walk-through-write-system-call}}\label{\detokenize{11_appendix::doc}}
\begin{sphinxadmonition}{note}{Todo}

Write this section.
\end{sphinxadmonition}


\chapter{Using \sphinxstyleliteralintitle{ptrace} system call to see the variables}
\label{\detokenize{12_appendix:using-ptrace-system-call-to-see-the-variables}}\label{\detokenize{12_appendix::doc}}

\chapter{Indices and tables}
\label{\detokenize{index:indices-and-tables}}\begin{itemize}
\item {} 
\DUrole{xref,std,std-ref}{genindex}

\item {} 
\DUrole{xref,std,std-ref}{modindex}

\item {} 
\DUrole{xref,std,std-ref}{search}

\end{itemize}



\renewcommand{\indexname}{Index}
\printindex
\end{document}